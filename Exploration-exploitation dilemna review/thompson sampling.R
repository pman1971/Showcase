######################################################################
### THOMPSON SAMPLING ON THREE UNKNOWN PROBABILITIES- UNRESTRICTED ###
######################################################################

# Clear all objects
rm(list=ls())

# Clear all plots
dev.off()

# Record random seed
set.seed(666)

# Declare number of unknown probabilities
probs.no= 3

# Create 3 random probabilities
probs.vec= c(0.25, 0.5, 0.75)
print(probs.vec)

#Initial parameters

# Create X axis probabiliities for density curve
p= seq(0,1, length= 1000)

# Initialise wins and losses
wins.tot.vec= rep.int(1, times= probs.no)
loss.tot.vec= rep.int(1, times= probs.no)

# Colour pallete for plots
palette<- c("red","green","blue")

# Set graphs
dev.off()

# Declare numer of plays
plays= 200

#Setup plots to deomonstrate TS demo
par(mar=c(2, 2, 2, 2))
layout(matrix(c(3,3,1,2), 2, 2, byrow = TRUE), 
       widths=c(1,1), heights=c(1,3))

layout.show(3)

##################
### START DEMO ###
##################

# Create vector to record maximum probability
prob.max.cuml= vector()
for(i in 1:plays)
{
  # Print play iteration
  print(i)
  #i=i+1
  
  # Sample random probabilites from current beta distibutions
  # As prior is unknown initiliase alpha and beta to 1 and 1 giving equal chance
  #drawn.probs= sapply(rep(1, probs.no), rbeta, shape1= 1+wins.tot.vec, shape2= 1+loss.tot.vec)
  
  drawn.probs= vector()
  for(dr in 1:probs.no)
  {
    drawn.probs[dr] = rbeta(1, wins.tot.vec[dr], loss.tot.vec[dr])
    
  }
  
  print(drawn.probs)
  
  # Determine the maximum density across three distibutions
  beta.densities= sapply(p, dbeta, shape1= wins.tot.vec, shape2= loss.tot.vec)
  ymax= max(beta.densities)
  
  # Create initial plot of 1st beta distibution
  plot(p, dbeta(p, wins.tot.vec[1], loss.tot.vec[1]), type= 'l', ylim= c(0, ymax), 
       col= palette[1])
  # Add lines to existing plot representing 2nd and 3rd distributions
  for(ln in 2:probs.no)
  {
    lines(p, dbeta(p, wins.tot.vec[ln], loss.tot.vec[ln]), type= 'l', col= palette[ln])
  }
  
  # Plot the random samples on existing plots of distributions
  for(pt in 1:probs.no)
  {
    points(drawn.probs[pt], dbeta(drawn.probs[pt], wins.tot.vec[pt], loss.tot.vec[pt]), 
           pch= 15, col= palette[pt])
  }
  
  # Employ Thompson sampling by taking the largest drawn sample
  prob.max= which.max(drawn.probs)
  # Record maximum for that iteration
  prob.max.cuml= c(prob.max.cuml, prob.max)
  
  # Redraw chosen beta distribution highlighting its selction
  lines(p, dbeta(p, wins.tot.vec[prob.max], loss.tot.vec[prob.max]), 
        type ="l", col= palette[prob.max], lwd= 3)
  
  points(drawn.probs[prob.max], dbeta(drawn.probs[prob.max], wins.tot.vec[prob.max], loss.tot.vec[prob.max]), 
         pch= 15, col= "black", cex= 1.5)
  
  # 2nd plot- Draw barplot represting number of times unknown probability played
  
  # Colour the bars
  bar.cols= rep("lightgrey", times= probs.no)
  
  # Update colour of bar corresponding to unknown probability played
  bar.cols[prob.max]= "darkgrey"
  
  # Label actual probabilities
  prop.actual= sprintf(probs.vec, fmt='%.2f')
  
  # Plot total number of plays by unknown probability
  bp= barplot(wins.tot.vec-1, col= bar.cols, main= paste("Play no", i),
              ylim= c(0, 1.1*max(wins.tot.vec-1)),
              names.arg= prop.actual)
  
  prob.curr= (wins.tot.vec-1)/((wins.tot.vec-1)+(loss.tot.vec-1))
  prob.curr= sprintf(prob.curr, fmt='%.2f')
  
  prob.act.curr= paste(prob.curr, "(", prop.actual, ")", sep= "")
  
  #text(bp, rep(0, probs.no), labels= prop.actual, pos= 1)
  #text(bp, rep(-1, probs.no), labels= prop.actual)
  
  # Label current proportion of wins against unknown probabilities
  text(bp, wins.tot.vec-1, labels= prob.curr, pos= 3, col= palette)
  
  # 3rd plot- Draw line plot displaying history of unknown probabilities played
  plot(prob.max.cuml, type= "l", ylim= c(1, probs.no))
  
  Sys.sleep(0.5) 
  
  # Play largest randomly drawn probability
  prob.play= probs.vec[prob.max]
  
  prob.win= sample(c(0,1), size= 1, replace= TRUE, prob = c(1-prob.play, prob.play))
  # Update wins
  wins.tot.vec[prob.max]= wins.tot.vec[prob.max]+prob.win
  # Update losses
  loss.tot.vec[prob.max]= loss.tot.vec[prob.max]+(1-prob.win)
}

##################################
### THOMPSON SAMPLING END DEMO ###
##################################

# Note that TS eventually finds the action with the highest underlying probability
# The other actions are not guaranteed to be correct but that is not the objective




